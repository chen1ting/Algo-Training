#include"ListSortingAlgo.h"
void ListSortingAlgo::InsertionSort()
{
	/* Insertion sort main idea:
	1. an outer loop to traverse through the list
	2. an inner loop to cmp the cuurent item with the previous items
	3. when met with the case of inversion(earlier items have larger values), Swap the index
	4. after 1 Swap, change
	*/
	for (int i = 0; i < n; i++) //starts from index 1 because the first element is trivially sorted
	{
		for (int j = i; j > 0; j--)
		{
			if (list[j] < list[j - 1])
				Swap(j, j - 1);
			else
				break;
		}
	}
}
void ListSortingAlgo::MergeSort(int start, int end)
{
	/* Merge sort main idea: devide & conquer
	1. find the base case: sublist have only 1 item left, return.
	2. if the sublist have 2 item, simply sort the small list
	3. from there, merge the sorted list of small sizes and get a new sorted list
	4. return the sorted list
	*/
	if (start >= end)
		return;
	else if (end -  start > 1)
	{
		int mid = (end + start) / 2;
		MergeSort(start, mid);
		MergeSort(mid+1, end);
	}
	//if start-end == 1, which means there are exactly 2 elements in the list, simply use the merge function to do the sorting
	Merge(start, end);
}

void ListSortingAlgo::QuickSort(int start, int end)
{
	/* QuickSort main idea:
	1. choose a pivot value
	2. based on the pivot value, sort the list into elements smaller than pivot, and larger than pivot
	3. recursively find the pivot for the next sublists
	*/
	if (start >= end)
		return;
	int pivot_pos = Partition(start, end);
	QuickSort(start, pivot_pos - 1);
	QuickSort(pivot_pos + 1, end);
}


//接口函数（打印 & 构造、析构函数）
ListSortingAlgo::ListSortingAlgo(int list_size)
{
	n = list_size;
	GenerateRandList();

}
ListSortingAlgo::~ListSortingAlgo()
{
	free(list); //list is generated by malloc in the Generator function, needs to be freed now
	if(additional_space_required)
		free(list_after_sorting);
}
void ListSortingAlgo::PrintList()
{
	printf("List size is %d.", n);
	for (int i = 0; i < n; i++)
	{
		if (i % 10 == 0)
			std::cout << std::endl;
		std::cout << list[i] << '\t';
	}
	std::cout << std::endl;
}

//Private Util Funcs below
void ListSortingAlgo::GenerateRandList()
{
	srand(time(NULL));
	list = (int*)malloc(sizeof(int) * n);
	for (int i = 0; i < n; i++)
		list[i] = (int)rand() % n;
}
void ListSortingAlgo::Swap(int i, int j)
{
	int tmp = list[i];
	list[i] = list[j];
	list[j] = tmp;
	return;
}
bool ListSortingAlgo::CheckCorrectness()
{
	for (int i = 0; i < n - 1; i++)
		if (list[i] > list[i + 1])
			return false;
	return true;
}
void ListSortingAlgo::Merge(int start, int end)
{
	int mid = (start + end) / 2;
	int list_p1 = start, list_p2 = mid+1, i, tmp;
	if (start >= end) //boundary check
		return;
	//double pointer
	while (list_p1 <= mid && list_p2 <= end)
	{
		if (list[list_p1] > list[list_p2])	
		{
			tmp = list[list_p2++];  //store the value of the smaller, because later its value would be replaced
			for (i = ++mid; i > list_p1; i--) //important for i to be ++mid instead of mid++
				list[i] = list[i - 1];
			list[list_p1++] = tmp;
		}
		else if(list[list_p1] < list[list_p2])//the only condition that doesn't require an insertion
			list_p1++;
		else
		{
			if (list_p1 == mid && list_p2 == end)
				break;
			tmp = list[list_p2++];
			list_p1++;
			for (i = ++mid; i > list_p1; i--)
				list[i] = list[i - 1];
			list[list_p1++] = tmp;
		}
	} 
}

int ListSortingAlgo::Partition(int start, int end)
{
	int mid = (start + end) / 2, pivot = list[mid];		//choose the middle position as pivot position
	Swap(start, mid);									//change the value of pivot position to the beginning
	int lst_small = start;								//initially, the last small element is the	pivot itsel
	for (int i = start + 1; i <= end; i++)
	{
		if (list[i] < pivot)	//only when the element is smaller than the pivot value, it needs to be switched into the smaller guys group
			Swap(++lst_small, i);
	}
	//after traversing all the elements in defined list
	Swap(lst_small, start);
	return lst_small;
}
